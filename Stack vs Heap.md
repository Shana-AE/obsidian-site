[[Stack vs Heap|Stack vs Heap]]
-   在像 Rust 这样的系统级编程语言里，一个值是在 stack上还是在 heap 上对语言的行为和你为什么要做某些决定是有更大的影响的
-   在你的代码运行的时候，Stack和 Heap 都是你可用的内存，但他们的结构很不相同。

## 存储数据

-   Stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）
    -   添加数据叫做压入栈
    -   移除数据叫做弹出栈
-   所有存储在Stack上的数据必须拥有已知的固定的大小
-   编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上
-   Heap 内存组织性差一些：
    -   当你把数据放入heap时，你会请求一定数量的空间
    -   操作系统在heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址
    -   这个过程叫做在heap上进行分配，有时仅仅称为“分配”
-   把值压到stack上不叫分配
-   因为指针是已知固定大小的，可以把指针存放在stack上
    -   但如果想要实际数据，你必须使用指针来定位
-   把数据压到 stack上要比在heap上分配快得多：
    -   因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端
-   在heap 上分配空间需要做更多的工作：
    -   操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配

## 访问数据

-   访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据
    -   对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快
-   如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上）
-   如果数据之间的距离比较远，那么处理速度就会慢一些（heap上）
    -   在heap 上分配大量的空间也是需要时间的

## 函数调用

-   当你的代码调用函数时，值被传入到函数（也包括指向heap 的指针）。函数本地的变量被压到 stack上。当函数结束后，这些值会从 stack上弹出

## 所有权存在的原因

-   所有权解决的问题
    -   跟踪代码的哪些部分正在使用heap的哪些数据
    -   最小化heap上的重复数据量
    -   清理heap上未使用的数据以避免空间不足
-   一旦你懂的了所有权，那么就不需要经常去想 stack或heap了
-   但是知道管理heap数据是所有权存在的原因，这有助于解释它为什么会这样工作。